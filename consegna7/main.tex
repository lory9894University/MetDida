\documentclass[a4paper]{article}
\setcounter{secnumdepth}{3}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{forest}
\usepackage{multicol}
\setlength{\columnsep}{3cm}
\usepackage{parskip}
\usepackage{changepage}
\usepackage[T1]{fontenc}
\usepackage{amsmath}
\usepackage{hyperref}
\usepackage{listings}
\usepackage{amsthm}
\usepackage{amssymb}
\usepackage{float}
\usepackage[utf8]{inputenc}
\usepackage{graphicx}
\usepackage[italian]{babel}
\usepackage{thmtools}
\usepackage{csquotes}
\usepackage{biblatex}
\graphicspath{{figures/}}
\usepackage{xcolor}
\addbibresource{refs.bib}

\begin{document}

\author{Lorenzo Dentis, lorenzo.dentis@edu.unito.it}
\title{Consegna 7 \\ \large NLD}
\maketitle

\section{Domande}
\begin{enumerate}
	\item Individuare altri momenti, oltre a quelli presentati (sezioni 4.4.1, 4.4.2, 4.4.3, 4.4.4) in cui è possibile usare il NLD per introdurre nuovi concetti.
	\item Nel vostro percorso scolastico/universitario avete mai "sentito la necessità" di un meccanismo/costrutto di programmazione prima che vi venisse spiegato? 
\end{enumerate}
\section{Risposte}
\subsection{1 usare il NLD per introdurre nuovi concetti}
Oltre agli esempi presentati nel paper \cite{NLD} io userei NLD in questi casi:
\begin{itemize}
	\item \textbf{Pattern}. Nel punto successivo racconterò della mia esperienza di NLD involontario riguardo al pattern Singleton. Trovo comunque che questo approcio sia ideale per presentare i pattern di qualsiasi tipo, soprattutto i Design Patterns.
	\item \textbf{Hashmap}. Mostrare che l'accesso in memoria può richiedere molto tempo, soprattutto con molti dati. Fare quindi svolgere problemi preliminari di estrazione di un dato (ad esempio usare un array o una lista) e poi fornire un dataset contenente moltissimi elementi.
	\item \textbf{OOP/struct}. Di nuovo, prendendo spunto dalla mia esperienza presenterei OOP tramite NLD, dato che usando strutture sempre più complesse nasce ad un certo punto la necessità di un costrutto avente una struttura decisa dallo sviluppatore. Per me ad esempio questa necessità è nata nel linguaggio C ed è stata risolta con l'utilizzo delle struct. Dalla definizione di oggetto si passa naturalmente all' object oriented programming
	\item \textbf{Strumenti di sincronizzazione}. Come semafori, messaggi, code, lock, mutex. Senza andare troppo nello specifico ci sono operazioni di mutua esclusione che possono essere svolte in maniera molto più intuitiva approfittando dell'astrazione. Si può certamente implementare tutti i tipi di mutua esclusione con i semafori, ma ci sono strumenti più sofisticati ed adatti alle singole esigenze. oppure si può fare l'opposto, partendo da questi strumenti più sofisticati spostarsi verso "il basso", quindi verso i semafori.
\end{itemize}
\subsection{2 Necessità di un costrutto di programmazione}
Mi è capitato due volte che io ricordi. Un esempio "voluto" si presenta nel corso "Algoritmi e Complessità", ove il professor Roversi presenta 3 problemi irrisolvibili con la nostre conoscenze attuali con lo scopo di mostrarci questa nostra "carenza". Un esempio lampante di "Necessity Learning Design", mi viene addirittura da pensare che il professore abbia sentito parlare di questa metodologia ed abbia voluto provarla.
Anche il resto di quel corso presenta molti momenti di "problem solving" con interazione della classe, forse più un esempio di "Productive failure" che di "Necessity Learning Design", in linea con il discorso fatto in conclusione della conferenza riguardo al non abusare del NDL\\ 
Invece in maniera più "naturale" mi è capitato con i Design Pattern, ricordo di aver avuto necessità di una programmazione più "strutturata". Ê successo molto tempo fa ma se non vado errato mi era capitato di aver necessità di utilizzare un Singleton (al tempo senza sapere cosa fosse) e di aver pensato "Ci sarà un modo di utilizzare una classe come se fosse un oggetto", aver cercato a lungo su internet ed aver scoperto il Singleton Pattern.

\end{document}
